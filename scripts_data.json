[
    {
        "relative_path": "zipbb/__init__.py",
        "file_name": "__init__.py",
        "code": "",
        "length": 0
    },
    {
        "relative_path": "zipbb/graph_creator.py",
        "file_name": "graph_creator.py",
        "code": "import networkx as nx\nimport json\nimport os\nimport matplotlib.pyplot as plt\n\ndef create_graph(script_data, max_length):\n    G = nx.DiGraph()\n    \n    for file_info in script_data:\n        relative_path = file_info['relative_path']\n        file_name = file_info['file_name']\n        file_length = file_info['length']\n        \n        # Normalize the file length by the maximum length\n        weight = file_length / max_length\n        \n        # Add a node with the weight\n        G.add_node(relative_path, weight=weight)\n        \n        # Create edges representing directory structure\n        parent_dir = os.path.dirname(relative_path)\n        if parent_dir and parent_dir != '.':\n            G.add_edge(parent_dir, relative_path)\n            # Ensure the parent directory node exists with a default weight\n            if not G.has_node(parent_dir):\n                G.add_node(parent_dir, weight=0.0)\n    \n    return G\n\ndef save_graph_to_json(G, json_file_path):\n    data = nx.readwrite.json_graph.node_link_data(G)\n    with open(json_file_path, 'w', encoding='utf-8') as f:\n        json.dump(data, f, indent=4)\n\ndef load_graph_from_json(json_file_path):\n    with open(json_file_path, 'r', encoding='utf-8') as f:\n        data = json.load(f)\n    G = nx.readwrite.json_graph.node_link_graph(data)\n    return G\n\ndef plot_graph(G):\n    pos = nx.spring_layout(G)\n    # Assign default weight if missing\n    node_sizes = [(G.nodes[node].get('weight', 0.0)) * 1000 for node in G.nodes]\n    nx.draw(G, pos, with_labels=True, node_size=node_sizes, node_color='lightblue', font_size=8, font_weight='bold', edge_color='gray')\n    # Save plot to file\n    plt.savefig('complexity_graph.png', format='PNG')\n    plt.show()\n",
        "length": 1709
    },
    {
        "relative_path": "zipbb/parser.py",
        "file_name": "parser.py",
        "code": "## Add function_graph argparse\nimport os\nimport json\nimport argparse\nimport networkx as nx\nimport ast\nimport matplotlib.pyplot as plt\nfrom .graph_creator import create_graph, save_graph_to_json, load_graph_from_json, plot_graph\nfrom .function_graph_creator import extract_function_data, create_function_graph, save_function_graph_to_json, load_function_graph_from_json, plot_function_graph\n\ndef read_zipbb_file(zipbb_path):\n    locations = []\n    with open(zipbb_path, 'r') as file:\n        for line in file:\n            line = line.strip()\n            if line and not line.startswith('#'):  # ignore empty lines and comments\n                locations.append(line)\n    return locations\n\ndef get_all_files(locations):\n    all_files = []\n    for location in locations:\n        if os.path.isfile(location):\n            all_files.append(location)\n        elif os.path.isdir(location):\n            for root, _, files in os.walk(location):\n                for file in files:\n                    all_files.append(os.path.join(root, file))\n    return all_files\n\ndef extract_script_data(files, max_chars=None):\n    script_data = []\n    file_lengths = []\n    \n    for file_path in files:\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                code = file.read(max_chars) if max_chars else file.read()\n                file_length = len(code)\n                file_lengths.append(file_length)\n                script_data.append({\n                    'relative_path': os.path.relpath(file_path),\n                    'file_name': os.path.basename(file_path),\n                    'code': code,\n                    'length': file_length\n                })\n        except (IOError, UnicodeDecodeError) as e:\n            print(f\"Skipping file {file_path}: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred while reading {file_path}: {e}\")\n\n    return script_data, max(file_lengths, default=1)\n\ndef write_json(data, output_path='scripts_data.json'):\n    with open(output_path, 'w', encoding='utf-8') as json_file:\n        json.dump(data, json_file, indent=4, ensure_ascii=False)\n\ndef create_zipbb_file():\n    content = '''# Add your file and directory paths here\nelegantLayout/\nrequirements.txt\n'''\n    with open('.zipbb', 'w') as file:\n        file.write(content)\n    print(\".zipbb file created successfully.\")\n\ndef main():\n    parser = argparse.ArgumentParser(description='Parse .zipbb file, extract script and function data, and create graphs.')\n    parser.add_argument('command', choices=['quickstart', 'zip', 'graph', 'function_graph'], help='Command to execute')\n    parser.add_argument('-m', type=int, help='Maximum number of characters to parse from each script file.')\n    args = parser.parse_args()\n\n    zipbb_path = '.zipbb'\n    if not os.path.exists(zipbb_path):\n        print(f\"{zipbb_path} not found.\")\n        return\n\n    if args.command == 'quickstart':\n        create_zipbb_file()\n        return\n\n    locations = read_zipbb_file(zipbb_path)\n    all_files = get_all_files(locations)\n\n    if args.command == 'zip':\n        script_data, max_length = extract_script_data(all_files, args.m)\n        output_json_path = 'scripts_data.json'\n        write_json(script_data, output_json_path)\n        \n        # Create and save the script file graph\n        G = create_graph(script_data, max_length)\n        save_graph_to_json(G, 'graph_data.json')\n        print(json.dumps(script_data, indent=4, ensure_ascii=False))\n    \n    elif args.command == 'graph':\n        # Load the script file graph from the saved JSON and plot it\n        G = load_graph_from_json('graph_data.json')\n        plot_graph(G)\n\n    elif args.command == 'function_graph':\n        # Extract functions and their usage\n        functions, function_usage = extract_function_data(all_files)\n        \n        # Create and save the function usage graph\n        G = create_function_graph(functions, function_usage)\n        save_function_graph_to_json(G, 'function_graph_data.json')\n        \n        # Plot the function usage graph\n        plot_function_graph(G)\n\nif __name__ == '__main__':\n    main()\n",
        "length": 4126
    },
    {
        "relative_path": "zipbb/function_graph_creator.py",
        "file_name": "function_graph_creator.py",
        "code": "import ast\nimport networkx as nx\nimport json\nimport matplotlib.pyplot as plt\n\ndef extract_function_data(files):\n    functions = {}\n    function_usage = {}\n    \n    for file_path in files:\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                content = file.read()\n                tree = ast.parse(content, filename=file_path)\n                \n                # Extract all function definitions\n                for node in ast.walk(tree):\n                    if isinstance(node, ast.FunctionDef):\n                        func_name = node.name\n                        functions[func_name] = {\n                            'defined_in': file_path,\n                            'calls': []\n                        }\n                \n                # Track calls to functions, including those imported\n                for node in ast.walk(tree):\n                    if isinstance(node, ast.Call):\n                        func_name = None\n                        \n                        # If the function is a simple call (e.g., function_name())\n                        if isinstance(node.func, ast.Name):\n                            func_name = node.func.id\n                        \n                        # If the function is an attribute call (e.g., module.function_name())\n                        elif isinstance(node.func, ast.Attribute):\n                            func_name = node.func.attr\n                        \n                        if func_name:\n                            if func_name not in functions:\n                                # Consider it an imported or external function\n                                functions[func_name] = {\n                                    'defined_in': \"imported_or_external\",\n                                    'calls': []\n                                }\n                            functions[func_name]['calls'].append(file_path)\n                            function_usage[func_name] = function_usage.get(func_name, 0) + 1\n                        \n        except (IOError, UnicodeDecodeError) as e:\n            print(f\"Skipping file {file_path}: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred while parsing {file_path}: {e}\")\n    \n    return functions, function_usage\n\ndef create_function_graph(functions, function_usage):\n    G = nx.DiGraph()\n    \n    for func_name, func_info in functions.items():\n        file_path = func_info['defined_in']\n        usage_count = function_usage.get(func_name, 0)\n        \n        # Add a node with the usage count as the weight\n        G.add_node(func_name, weight=usage_count, defined_in=file_path)\n        \n        # Create edges representing function calls\n        for caller in func_info['calls']:\n            G.add_edge(caller, func_name)\n    \n    return G\n\ndef save_function_graph_to_json(G, json_file_path):\n    data = nx.readwrite.json_graph.node_link_data(G)\n    with open(json_file_path, 'w', encoding='utf-8') as f:\n        json.dump(data, f, indent=4)\n\ndef load_function_graph_from_json(json_file_path):\n    with open(json_file_path, 'r', encoding='utf-8') as f:\n        data = json.load(f)\n    G = nx.readwrite.json_graph.node_link_graph(data)\n    return G\n\ndef plot_function_graph(G):\n    pos = nx.spring_layout(G)\n    node_sizes = [(G.nodes[node].get('weight', 0.0)) * 1000 for node in G.nodes]\n    nx.draw(G, pos, with_labels=True, node_size=node_sizes, node_color='lightgreen', font_size=8, font_weight='bold', edge_color='blue')\n    # Save plot to file\n    plt.savefig('function_graph.png', format='PNG')\n    plt.show()\n    \n    ",
        "length": 3616
    },
    {
        "relative_path": "zipbb/__main__.py",
        "file_name": "__main__.py",
        "code": "from .parser import main\n\nif __name__ == '__main__':\n    main()\n",
        "length": 64
    }
]